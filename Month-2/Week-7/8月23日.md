## 需求待排期

- [ ] [【SG】美股IPOB606 美股IPO佣金扣款和B608 IPO中签投资咨询费需要收取消费税](http://jira.yxzq.com/browse/JYTRADE-4419)

---

```html
解决：[Vue warn]: Failed to resolve component: center
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement. 
  at <AuditList onVnodeUnmounted=fn<onVnodeUnmounted> ref=Ref< undefined > key="upgrade-manage" > 
  at <KeepAlive include= [] > 
  at <RouterView> 
  at <Home onVnodeUnmounted=fn<onVnodeUnmounted> ref=Ref< undefined > > 
  at <KeepAlive> 
  at <RouterView> 
  at <App>
      
> 这个警告表明 Vue 在解析组件时无法找到名为 "center" 的组件。实际上我是想用center标签让按钮居中，既然vue使用center标签会报warn，那么使用flex布局或text-align的方式来替换居中方案吧
      
      <div style="display: flex; justify-content: center;">
          <el-button>居中显示</el-button>
      </div>
      
      <el-button style="text-align: center; width: 100%;">居中显示</el-button>
```

## 待看文章

> 小结：官方文档阅读难（翻译中文文档的）先看社区文章（掘金、博客园等等），再看官方文档。反之则reverse进行

- [x] [关于常用的http请求头以及响应头详解](https://juejin.cn/post/6844903745004765198)
- [x] [HTTP 标头（header）| MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)
- [x] [Flex 布局教程：语法篇](https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)
  - [ ] [彻底理解CSS Flexbox布局，看这一篇就够了！](https://juejin.cn/post/7004622232378966046)
- [x] [路由守卫 | Router官方文档](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html)
- [x] [使用 Promise | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)
  - [x] [事件循环 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Event_loop#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF) ([[8月24日#事件循环 | 事件循环的定义和过程]])
  - [x] [Promise | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)
  - [x] [Promise.reject() | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject)
  - [x] [Promise.resolve() | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve)
  - [x] [Promise.prototype.then() | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)
  - [x] [Promise.prototype.catch() | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch)
- [x] [大白话讲解Promise（一）](https://www.cnblogs.com/lvdabao/p/es6-promise-1.html)
- [x] [高效获取信息，你需要这份 RSS 入门指南](https://sspai.com/post/56391)
  - [x] [论 RSS 的「复兴」](https://sspai.com/post/43998)
  - [x] [RSSHub Radar — 订阅一个 RSS 源不应该这么难](https://sspai.com/post/56079)（搜一下RSS如何搭建，有哪些好用的RSS阅读器）
- [x] [组件基础 | Vue官方文档](https://cn.vuejs.org/guide/essentials/component-basics.html)
  - [x] [组件注册](https://cn.vuejs.org/guide/components/registration.html#local-registration)
  - [x] [Props](https://cn.vuejs.org/guide/components/props.html)
  - [x] [组件事件](https://cn.vuejs.org/guide/components/events.html)
  - [x] [透传 Attributes](https://cn.vuejs.org/guide/components/attrs.html)
  - [ ] [状态管理](https://cn.vuejs.org/guide/scaling-up/state-management.html)
    - [x] [reactive()](https://cn.vuejs.org/api/reactivity-core.html#reactive)
      - [x] [ref()](https://cn.vuejs.org/api/reactivity-core.html#ref)
        - [x] [shallowRef()](https://cn.vuejs.org/api/reactivity-advanced.html#shallowref)
      - [x] [shallowReactive()](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive)
  - [ ] [服务端渲染 (SSR)](https://cn.vuejs.org/guide/scaling-up/ssr.html)
  - [ ] [依赖注入](https://cn.vuejs.org/guide/components/provide-inject.html)
- [ ] [事件循环：微任务和宏任务](https://zh.javascript.info/event-loop)
- [ ] [微任务、宏任务与Event-Loop](https://juejin.cn/post/6844903657264136200)
- [x] [响应式设计 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Responsive_Design)
- [ ] [媒体查询入门指南 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Media_queries)
- [ ] [面试官：什么是响应式设计？响应式设计的基本原理是什么？如何做？](https://vue3js.cn/interview/css/responsive_layout.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)
- [ ] [前端响应式布局原理与方案（详细版）](https://juejin.cn/post/6844903814332432397)
- [ ] [渲染页面：浏览器的工作原理](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work)
- [ ] [Proxy | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
- [x] [带你深入了解 GitLab CI/CD 原理及流程](https://segmentfault.com/a/1190000037748013)
- [ ] 在 JavaScript 中，[并行执行](https://www.wikiwand.com/zh/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97)只能通过 [worker 线程](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API)实现。
- [ ] [腾讯云-对象存储 | 快速入门](https://cloud.tencent.com/document/product/436/11459)

```html
这两种写法有什么区别
        // next(vm => {
        // vm.$nextTick(() => {
        //     console.log('0823-beforeRouteEnter')
        //     vm.handleClickSearch(1)
        //     vm.handleClickSearch(2)
        //     vm.handleClickSearch(3)
        // })
        next(vm => {
            console.log('0823-beforeRouteEnter')
            vm.handleClickSearch(1)
            vm.handleClickSearch(2)
            vm.handleClickSearch(3)
        })
```

> 在你提供的两种写法中，主要的区别在于对 `vm.$nextTick` 方法的使用。
>
> 1. 第一种写法：
>    ```javascript
>    next(vm => {
>        vm.$nextTick(() => {
>            console.log('0823-beforeRouteEnter');
>            vm.handleClickSearch(1);
>            vm.handleClickSearch(2);
>            vm.handleClickSearch(3);
>        });
>    });
>    ```
>    在这种写法中，使用了 `vm.$nextTick` 来确保在 DOM 更新后执行回调函数。这意味着在回调函数内部的代码会等到 DOM 更新完成后才执行。这对于在 DOM 更新后执行操作是非常有用的，例如修改页面上的元素或触发异步操作。
>
> 2. 第二种写法：
>    ```javascript
>    next(vm => {
>        console.log('0823-beforeRouteEnter');
>        vm.handleClickSearch(1);
>        vm.handleClickSearch(2);
>        vm.handleClickSearch(3);
>    });
>    ```
>    在这种写法中，直接在 `next` 的回调函数中调用了 `vm.handleClickSearch`，没有使用 `vm.$nextTick`。这意味着这些方法调用会在下一个事件循环中执行，而不必等到 DOM 更新完成。
>
> 综上所述，两种写法都可以实现你的目标，但是如果你的目的是确保在 DOM 更新后执行回调，**建议使用第一种写法**，以便更好地控制操作的执行时机。如果你只需要在下一个事件循环中执行操作，那么可以使用第二种写法。

​	

### 那我使用了beforeRouteEnter 页面状态就会更新吗

`beforeRouteEnter` 守卫本身并不会直接导致页面状态的更新。它是在路由进入之前被调用的一个钩子函数，可以用于在页面加载之前执行某些操作，例如获取数据、验证权限等。在 `beforeRouteEnter` 钩子中执行的操作不会导致页面状态的更新。

如果你在 `beforeRouteEnter` 钩子内部执行了一些操作，而这些操作会影响到页面状态，那么页面状态的更新通常是在钩子之后进行的。Vue 在数据更新后会触发重新渲染页面，从而呈现更新后的状态。

如果你想确保在路由切换后页面状态已更新，你可以考虑在 `beforeRouteEnter` 钩子内部执行操作后，**使用 `vm.$nextTick` 来确保 DOM 更新后再执行相关操作，以便在新页面上显示正确的状态。**

总之，`beforeRouteEnter` 钩子用于在路由切换前执行一些操作，而页面状态的更新通常是在 DOM 更新后进行的。

​	

![image-20230823103327300](8月23日.assets/image-20230823103327300.png)

​	

## undefined返回的是true吗？

在 JavaScript 中，`undefined` 是一个特殊的值，不是布尔值 `true` 或 `false`。当你使用条件语句（例如 `if` 语句）来判断一个变量或表达式的真假时，`undefined` 会被视为假值。

示例：

```javascript
let variable;

if (variable) {
  console.log("Variable is truthy"); // This will not be printed because `variable` is `undefined`
} else {
  console.log("Variable is falsy"); // This will be printed because `variable` is `undefined`
}
```

在上面的示例中，由于 `variable` 是 `undefined`，它被视为假值，因此进入了 `else` 分支。

总结：`undefined` 不是 `true`，而是假值，会被视为条件判断中的假。

​	

## RFC 是什么

"RFC" 通常是 "Request for Comments" 的缩写，它是一种标准文档的格式，用于描述互联网上的协议、方法、过程等。RFC 是一种用于记录和定义互联网标准的文档类型，它们通常由技术专家、研究人员和社区成员编写，然后由互联网工程任务组（IETF）或其他标准化组织审核和发布。

RFC 文档对于互联网上各种协议和标准的定义非常重要。例如，HTTP（超文本传输协议）的规范、SMTP（简单邮件传输协议）的规范以及许多其他网络协议的规范都以 RFC 文档的形式发布和维护。这些文档提供了详细的技术规范，以确保在不同系统和平台之间实现互操作性。

RFC 文档按照一定的编号和分类体系进行组织，每个文档都有一个唯一的编号，例如 "RFC 2616" 表示 HTTP 1.1 的规范。这些文档可以在互联网上免费获取，任何人都可以查阅并了解相关的标准和协议。

​	

## 导航守卫的next参数用来干嘛

在 Vue 的导航守卫中，`next` 参数是一个函数，用来控制路由跳转的行为。它是一个必须调用的函数，在导航守卫中调用 `next` 函数，才会继续执行路由跳转。

`next` 函数可以接受一个可选的参数，用来指定跳转的行为。它可以有以下几种用法：

1. 不传递参数：继续执行路由跳转，进入目标路由。

2. 传递 `false`：阻止路由跳转，保持在当前路由。

3. 传递一个路由对象：跳转到指定的路由。例如：`next({ path: '/login' })`。

4. 传递一个命名路由：跳转到具名的路由。例如：`next({ name: 'home' })`。

5. 传递一个带有 `replace: true` 的路由对象或命名路由：执行替换当前路由而不是添加新的历史记录。例如：`next({ path: '/login', replace: true })`。

通常情况下，至少需要调用一次 `next` 函数，以便在导航守卫中控制路由的行为。不同的 `next` 调用会产生不同的导航结果，从而影响用户的路由跳转体验。

​	

## 路由守卫

> [官方文档 | 路由守卫](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB)

### 全局前置守卫

当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于等待中。

你可以使用 `router.beforeEach` 注册一个全局前置守卫：

```js
const router = createRouter({ ... })

router.beforeEach((to, from) => {
  // ...
  // 返回 false 以取消导航
  return false
})
```

​	

### 全局解析守卫

解析守卫刚好会在导航被确认之前、所有组件内守卫和异步路由组件被解析之后调用。

`router.beforeResolve` 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置。

​	

### 全局后置钩子

`router.afterEach` 这些钩子不会接受 next 函数也不会改变导航本身，它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。

它们也反映了 navigation failures 作为第三个参数：

```js
router.afterEach((to, from, failure) => {
  if (!failure) sendToAnalytics(to.fullPath)
})
```

​	

### 路由独享的守卫

`beforeEnter` 守卫 **只在进入路由时触发**，不会在 params、query 或 hash 改变时触发。

​	

### 组件内的守卫

最后，你可以在路由组件内直接定义路由导航守卫(传递给路由配置的)

#### 可用的配置 API

你可以为路由组件添加以下配置：

- `beforeRouteEnter`
- `beforeRouteUpdate`
- `beforeRouteLeave`

```js
const UserDetails = {
  template: `...`,
  beforeRouteEnter(to, from) {
    // 在渲染该组件的对应路由被验证前调用
    // 不能获取组件实例 `this` ！
    // 因为当守卫执行时，组件实例还没被创建！
  },
  beforeRouteUpdate(to, from) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，
    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`
  },
  beforeRouteLeave(to, from) {
    // 在导航离开渲染该组件的对应路由时调用
    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`
  },
}
```

beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。

不过，你可以通过传一个回调给 next 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数：

```js
beforeRouteEnter (to, from, next) {
  next(vm => {
    // 通过 `vm` 访问组件实例
  })
}
```

注意 `beforeRouteEnter` 是支持给 `next` 传递回调的唯一守卫。对于 `beforeRouteUpdate` 和 `beforeRouteLeave` 来说，`this` 已经可用了，所以*不支持* 传递回调，因为没有必要了

​	

### 完整的导航解析流程

1. 导航被触发。
2. 在失活的组件里调用 `beforeRouteLeave` 守卫。
3. 调用全局的 `beforeEach` 守卫。
4. 在重用的组件里调用 `beforeRouteUpdate` 守卫(2.2+)。
5. 在路由配置里调用 `beforeEnter`。
6. 解析异步路由组件。
7. 在被激活的组件里调用 `beforeRouteEnter`。
8. 调用全局的 `beforeResolve` 守卫(2.5+)。
9. 导航被确认。
10. 调用全局的 `afterEach` 钩子。
11. 触发 DOM 更新。
12. 调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入。

​	

github除了issue还有discussions

![image-20230823114907603](8月23日.assets/image-20230823114907603.png)

​	

[lodash CDN](https://www.jsdelivr.com/package/npm/lodash)

​	

## JS 加"use strict"; 和不加有什么区别

在JavaScript中，添加"use strict";或使用严格模式（strict mode）与不使用严格模式之间有一些重要的区别：

1. **错误检测：** 使用严格模式可以帮助你更早地捕获代码中的潜在错误。在严格模式下，一些不合规范的行为会抛出错误，而不会默默地导致不明确的行为或安全问题。

2. **变量声明：** 在严格模式下，变量必须先声明后使用，否则会抛出错误。而在非严格模式下，如果你忘记声明变量，JavaScript会隐式地创建一个全局变量，这可能会导致不易发现的问题。

3. **保留字：** 严格模式引入了一些新的保留字，这些保留字在非严格模式下可以用作标识符（变量名、函数名等）。在严格模式下使用这些保留字会导致语法错误。

4. **this 的值：** 在严格模式下，全局上下文中的this的值是undefined，而在非严格模式下，this的值可能是全局对象（在浏览器环境中通常是window）。

5. **函数参数：** 严格模式要求函数的参数名必须是唯一的，而在非严格模式下，可以使用相同的参数名。

6. **eval 函数：** 在严格模式下，eval的行为更受限制，它创建的变量不会被提升到包含作用域，而在非严格模式下，eval的变量可能会影响包含作用域。

7. **八进制字面量：** 在非严格模式下，八进制字面量（如0123）被解释为八进制数值，而在严格模式下，会抛出错误。

总的来说，严格模式有助于编写更加健壮、可维护和安全的JavaScript代码，因为它会捕获一些潜在的问题，并限制一些不合规范的行为。因此，在新的JavaScript项目中，推荐始终使用严格模式。你可以通过在代码文件或函数的开头添加"use strict";来启用严格模式。

### 介绍一下 eval 函数

`eval` 是 JavaScript 中的一个内置函数，用于将字符串作为 JavaScript 代码来执行。它的基本语法如下：

```javascript
eval(string)
```

- `string`：一个包含要执行的 JavaScript 代码的字符串。

`eval` 函数的主要功能是将传递给它的字符串解析为 JavaScript 代码，并在当前的执行环境中执行该代码。这可以用于动态地生成和执行 JavaScript 代码。然而，`eval` 应该谨慎使用，因为它具有潜在的安全风险和性能问题。

以下是一些 `eval` 函数的用法示例：

1. **动态创建变量和函数**：

   ```javascript
   var varName = "x";
   var x = 10;
   eval("var " + varName + " = 20;");
   console.log(x); // 输出 20
   ```

   这个示例中，`eval` 用于动态创建一个变量。

2. **执行动态生成的代码**：

   ```javascript
   var code = "console.log('Hello, world!');";
   eval(code); // 输出 "Hello, world!"
   ```

   这里，`eval` 用于执行存储在变量 `code` 中的动态生成的代码。

尽管 `eval` 在某些情况下非常有用，但它存在一些潜在的问题：

- **安全性问题**：如果不谨慎使用，`eval` 可能会执行恶意代码。因此，不建议将未经验证的用户输入直接传递给 `eval`。

- **性能问题**：由于 `eval` 在运行时解析代码，它的性能可能比直接编写的代码慢。

出于这些原因，应该尽量避免在生产环境中使用 `eval`，并且在使用时要格外小心，确保只在可信任的情况下使用。在大多数情况下，可以使用更安全和可控的替代方法来达到相同的目的。

## CI / CD

为了使用GitLab CI/CD，你需要一个托管在GitLab上的应用程序代码库，并且在根目录中的 `.gitlab-ci.yml` 文件中指定构建、测试和部署的脚本。

为了可视化处理过程，假设添加到配置文件中的所有脚本与在计算机的终端上运行的命令相同。一旦你已经添加了.gitlab-ci.yml到仓库中，GitLab将检测到该文件，并使用名为GitLab Runner的工具运行你的脚本。该工具的操作与终端类似。

​	

## 理解

### 链式调用-嵌套

链式调用中的第一个 promise 是嵌套最深的一个，也将是第一个被弹出的。 

```js
(promise D, (promise C, (promise B, (promise A) ) ) )
```

当你开始解决这个 Promise 链时，Promise D 首先被解决，然后结果传递给 Promise C，接着是 Promise B，最后是 Promise A。这是因为最深嵌套的 Promise D 是第一个被解决的，然后按照链式结构依次传递结果，直到达到最外层的 Promise A。

![image-20230901104728687](8月23日.assets/image-20230901104728687.png)

### Promise 执行顺序

下面第二行代码和第三行代码是依次顺序执行，还是同时执行 

```js
const promiseA = new Promise(myExecutorFunc); 
const promiseB = promiseA.then(handleFulfilled1, handleRejected1); 
const promiseC = promiseA.then(handleFulfilled2, handleRejected2);
```

> 在这段代码中，第二行和第三行代码是依次顺序执行的。

让我解释一下：

1. 第一行代码创建了一个 Promise 实例 `promiseA`，并且它的构造函数中的 `myExecutorFunc` 会立即执行。这意味着 `myExecutorFunc` 内的代码会立即执行。

2. 第二行代码创建了一个新的 Promise 实例 `promiseB`，并将 `handleFulfilled1` 和 `handleRejected1` 作为 `promiseA` 被解决（fulfilled）或被拒绝（rejected）时的处理函数。这里是一个 `.then()` 方法，它会在 `promiseA` 被解决之后才会执行。

3. 第三行代码创建了另一个新的 Promise 实例 `promiseC`，与第二行类似，它将 `handleFulfilled2` 和 `handleRejected2` 作为 `promiseA` 被解决或被拒绝时的处理函数。同样，这个 `.then()` 方法也会在 `promiseA` 被解决之后才会执行。

因此，第二行和第三行代码中的 `.then()` 方法会等待 `promiseA` 被解决后才会执行，而且它们会依次顺序执行。在 `promiseA` 被解决后，会依次执行 `handleFulfilled1`、`handleRejected1`、`handleFulfilled2` 和 `handleRejected2`。它们不会同时执行。

​	

### 并发是否相当于同时执行

是的，"并发"通常用来表示多个任务在时间上重叠地执行，尽管它们不一定是真正的同时执行。在计算机领域，"并发"是指系统能够同时处理多个任务，即使这些任务在实际时间上可能不会完全重叠。

并发可以通过多种方式实现，包括多线程、多进程、异步编程等。在这些情况下，多个任务可以同时在不同的线程、进程或执行上下文中运行。然而，由于计算机资源有限，实际上只有少数任务能够在同一时刻得到处理，因此它们可能会在极短的时间间隔内交替执行。

在某些情况下，任务之间的切换可能非常快，以至于它们看起来几乎是同时执行的。但要注意，并发不等于真正的同时执行，因为在多核处理器上，多个任务可以同时在不同的核心上执行，而在单核处理器上，任务可能会交替地分时执行。

总之，"并发"指的是多个任务在时间上重叠地执行，但并不一定是真正的同时执行。这取决于系统的硬件和调度机制。

​	

### 持续交付和持续部署的联系与区别

> 持续集成：你可以预先创建一组脚本来自动构建和测试每次推送的代码，减少向应用程序引入错误的机会

联系：递增关系

流程：持续集成(CI) → 持续交付(CD) → 持续部署(CD)

区别：

- 持续交付会将每个功能或改进集成到主分支，涉及手动的交付和部署决策，需要开发组长手动部署
- 持续部署意味着你的改进或新功能可以立即提供给最终用户，无需人为干预，它是自动部署的

​	

## 实践

- 通常，如果你不知道一个值是否是 Promise，那么最好使用 [`Promise.resolve(value)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve) 将其转换成 Promise 对象，并将返回值作为 Promise 来处理。

- resolve(...) 函数中传入的任何内容，它不一定是字符串，但如果它只是一个成功的消息，那么它大概率是字符串

- - [ ] 手写实现Promise基本使用

  ```js
  // 为了尝试错误处理，使用“阈值”值会随机地引发错误。
  const THRESHOLD_A = 8; // 可以使用 0 使错误必现
  
  function tetheredGetNumber(resolve, reject) {
    setTimeout(() => {
      const randomInt = Date.now();
      const value = randomInt % 10;
      if (value < THRESHOLD_A) {
        resolve(value);
      } else {
        reject(`太大了：${value}`);
      }
    }, 500);
  }
  
  function determineParity(value) {
    const isOdd = value % 2 === 1;
    return { value, isOdd };
  }
  
  function troubleWithGetNumber(reason) {
    const err = new Error("获取数据时遇到问题", { cause: reason });
    console.error(err);
    throw err;
  }
  
  function promiseGetWord(parityInfo) {
    return new Promise((resolve, reject) => {
      const { value, isOdd } = parityInfo;
      if (value >= THRESHOLD_A - 1) {
        reject(`还是太大了：${value}`);
      } else {
        parityInfo.wordEvenOdd = isOdd ? "奇数" : "偶数";
        resolve(parityInfo);
      }
    });
  }
  
  new Promise(tetheredGetNumber)
    .then(determineParity, troubleWithGetNumber)
    .then(promiseGetWord)
    .then((info) => {
      console.log(`得到了：${info.value}, ${info.wordEvenOdd}`);
      return info;
    })
    .catch((reason) => {
      if (reason.cause) {
        console.error("已经在前面处理过错误了");
      } else {
        console.error(`运行 promiseGetWord() 时遇到问题：${reason}`);
      }
    })
    .finally((info) => console.log("所有回调都完成了"));
  
  ```

- 

​	

## 记忆

### 组件基础

#### 使用组件

通过 `<script setup>`，导入的组件都在模板中直接可用。

ButtonCounter.vue

```vue
<script setup>
import { ref } from 'vue'

const count = ref(0)
</script>

<template>
  <button @click="count++">
    You clicked me {{ count }} times.
  </button>
</template>
```

App.vue

```vue
<script setup>
import ButtonCounter from './ButtonCounter.vue'
</script>

<template>
	<h1>Here are many child components!</h1>
	<ButtonCounter />
	<ButtonCounter />
	<ButtonCounter />
</template>
```

你会注意到，每当点击这些按钮时，每一个组件都维护着自己的状态，是不同的 `count`。这是因为每当你使用一个组件，就创建了一个新的**实例**。

#### Props传递示例

BlogPost.vue

```vue
<script setup>
defineProps(['title'])
</script>

<template>
  <h4>{{ title }}</h4>
</template>
```

App.vue

```vue
<script setup>
import { ref } from 'vue'
import BlogPost from './BlogPost.vue'
  
const posts = ref([
  { id: 1, title: 'My journey with Vue' },
  { id: 2, title: 'Blogging with Vue' },
  { id: 3, title: 'Why Vue is so fun' }
])
</script>

<template>
	<BlogPost
  	v-for="post in posts"
	  :key="post.id"
  	:title="post.title"
	></BlogPost>
</template>
```

留意我们是如何使用 `v-bind` 来传递动态 prop 值的。当事先不知道要渲染的确切内容时，这一点特别有用。

#### @ 后面可以是标准的 DOM 事件名称，也可以是自定义事件名称，这个有什么区别吗

`@` 后面可以是标准的 DOM 事件名称，也可以是自定义事件名称，它们在用法和行为上有一些区别：

1. **标准 DOM 事件名称：** 当你使用标准 DOM 事件名称时，例如 `@click`、`@input`、`@keydown` 等，Vue.js会在DOM元素上直接绑定对应的DOM事件监听器。这意味着你监听的是底层的浏览器事件，可以在组件中处理与DOM事件相关的行为。

   示例：
   
   ```html
   <button @click="handleClick">点击我</button>
   ```

   在这种情况下，`@click` 监听了按钮的点击事件。

2. **自定义事件名称：** 当你使用自定义事件名称时，例如 `@enlarge-text`、`@custom-event` 等，你实际上是在组件之间建立了一种自定义通信方式。你需要在触发事件的组件中使用 `$emit` 方法触发自定义事件，然后在父组件中使用 `@` 监听该事件。这允许不同组件之间的数据和事件传递。

   示例：

   ```html
   <custom-component @enlarge-text="handleEnlargeText"></custom-component>
   ```

   在这种情况下，`@enlarge-text` 监听了一个自定义事件，该事件由 `custom-component` 组件触发。

总的来说，区别在于标准 DOM 事件是与底层浏览器事件相关的，而自定义事件是组件之间的通信机制。你可以根据具体的需求和场景来选择使用哪种方式。标准 DOM 事件通常用于处理用户与DOM元素的交互，而自定义事件通常用于组件之间的数据传递和通信。

#### 监听事件（$emit示例）

子组件可以通过调用内置的 $emit 方法，通过传入事件名称来抛出一个事件：

BlogPost.vue

```vue
<script setup>
defineProps(['title'])
defineEmits(['enlarge-text'])
</script>

<template>
  <div class="blog-post">
    <h4>{{ title }}</h4>
    <button @click="$emit('enlarge-text')">Enlarge text</button>
  </div>
</template>
```

App.vue

```vue
<script setup>
import { ref } from 'vue'
import BlogPost from './BlogPost.vue'
  
const posts = ref([
  { id: 1, title: 'My journey with Vue' },
  { id: 2, title: 'Blogging with Vue' },
  { id: 3, title: 'Why Vue is so fun' }
])

const postFontSize = ref(1)
</script>

<template>
	<div :style="{ fontSize: postFontSize + 'em' }">
    <BlogPost
      v-for="post in posts"
      :key="post.id"
      :title="post.title"
      @enlarge-text="postFontSize += 0.1"
    ></BlogPost>
  </div>
</template>
```

因为有了 `@enlarge-text="postFontSize += 0.1"` 的监听，父组件会接收这一事件，从而更新 `postFontSize` 的值。

#### slot

AlertBox.vue

```vue
<template>
  <div class="alert-box">
    <strong>Error!</strong>
    <br/>
    <slot />
  </div>
</template>

<style scoped>
.alert-box {
  color: #666;
  border: 1px solid red;
  border-radius: 4px;
  padding: 20px;
  background-color: #f8f8f8;
}
  
strong {
	color: red;    
}
</style>
```

如上所示，我们使用 `<slot>` 作为一个占位符，父组件传递进来的内容就会渲染在这里。

App.vue

```vue
<script setup>
import AlertBox from './AlertBox.vue'
</script>

<template>
	<AlertBox>
  	Something bad happened.
	</AlertBox>
</template>
```

#### 动态组件

```vue
<!-- vue3这组件导入不需要注册吗？-->
<script setup>
import Home from './Home.vue'
import Posts from './Posts.vue'
import Archive from './Archive.vue'
import { ref } from 'vue'
 
const currentTab = ref('Home')

const tabs = {
  Home,
  Posts,
  Archive
}
</script>
```

在 Vue 3 的 `<script setup>` 语法中，不需要显式注册组件，因为它自动处理了组件的注册。这是 `<script setup>` 的一个方便之处，你只需要导入组件，并且在模板中使用它们，而不需要在组件选项中显式注册它们。

在你的示例中，你导入了 `Home`、`Posts` 和 `Archive` 组件，并将它们包含在 `tabs` 对象中。只要你在模板中使用了这些组件，Vue 3 的编译器会自动将它们注册为你的组件。

例如，如果你在模板中使用了 `Home` 组件，无需额外的注册步骤，它会正常工作：

```vue
<template>
  <div>
    <component :is="tabs[currentTab]" />
  </div>
</template>
```

上述代码中，`<component :is="tabs[currentTab]" />` 会根据 `currentTab` 的值来动态渲染 `Home`、`Posts` 或 `Archive` 组件，而无需在组件选项中显式注册它们。

这种自动注册的特性使得 `<script setup>` 更加简洁和便捷，减少了繁琐的注册步骤，同时保持了代码的可读性。

​	

##### 场景

有些场景会需要在两个组件间来回切换，比如 Tab 界面：

Home.vue

```vue
<template>
  <div class="tab">
    Home component
  </div>
</template>
```

Posts.vue

```vue
<template>
  <div class="tab">
    Posts component
  </div>
</template>
```

Archive.vue

```vue
<template>
  <div class="tab">
    Archive component
  </div>
</template>
```

App.vue

```vue
<script setup>
import Home from './Home.vue'
import Posts from './Posts.vue'
import Archive from './Archive.vue'
import { ref } from 'vue'
 
const currentTab = ref('Home')

const tabs = {
  Home,
  Posts,
  Archive
}
</script>

<template>
  <div class="demo">
    <button
       v-for="(_, tab) in tabs"
       :key="tab"
       :class="['tab-button', { active: currentTab === tab }]"
       @click="currentTab = tab"
     >
      {{ tab }}
      <!--这里本来有个疑问，为什么用 {{tab}} 不用 {{_}} 发现tabs定义的对象只有key，没有value，所以循环的value用占位符_代替-->
    </button>
	  <component :is="tabs[currentTab]" class="tab"></component>
  </div>
</template>

<style>
.demo {
  font-family: sans-serif;
  border: 1px solid #eee;
  border-radius: 2px;
  padding: 20px 30px;
  margin-top: 1em;
  margin-bottom: 40px;
  user-select: none;
  overflow-x: auto;
}

.tab-button {
  padding: 6px 10px;
  border-top-left-radius: 3px;
  border-top-right-radius: 3px;
  border: 1px solid #ccc;
  cursor: pointer;
  background: #f0f0f0;
  margin-bottom: -1px;
  margin-right: -1px;
}
.tab-button:hover {
  background: #e0e0e0;
}
.tab-button.active {
  background: #e0e0e0;
}
.tab {
  border: 1px solid #ccc;
  padding: 10px;
}
</style>
```

在上面的例子中，被传给 `:is` 的值可以是以下几种：

- 被注册的组件名
- 导入的组件对象

你也可以使用 `is` attribute 来创建一般的 HTML 元素。

当使用 `<component :is="...">` 来在多个组件间作切换时，被切换掉的组件会被卸载。我们可以通过 [<KeepAlive>组件](https://cn.vuejs.org/guide/built-ins/keep-alive.html)强制被切换掉的组件仍然保持“存活”的状态。

#### DOM 模板解析注意事项

![image-20230911164321253](8月23日.assets/image-20230911164321253.png)

##### [`<component>`](https://cn.vuejs.org/api/built-in-special-elements.html#component)

```vue
<script setup>
import { ref } from 'vue'

const tag = ref('input')
const username = ref('')
</script>

<template>
  <!-- 由于 'input' 是原生 HTML 元素，因此这个 v-model 不起作用 -->
  <component :is="tag" v-model="username" />
</template>
```

在实践中，这种极端情况并不常见，因为原生表单字段通常包裹在实际应用的组件中。如果确实需要直接使用原生元素，那么你可以手动将 `v-model` 拆分为 attribute 和事件。

​	

##### [is](https://cn.vuejs.org/api/built-in-special-attributes.html#is)

用于绑定[动态组件](https://cn.vuejs.org/guide/essentials/component-basics.html#dynamic-components)。

- **预期**：`string | Component`

- **用于原生元素** 3.1+

  当 `is` attribute 用于原生 HTML 元素时，它将被当作 [Customized built-in element](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example)，其为原生 web 平台的特性。

  但是，在这种用例中，你可能需要 Vue 用其组件来替换原生元素，如 [DOM 模板解析注意事项](https://cn.vuejs.org/guide/essentials/component-basics.html#dom-template-parsing-caveats)所述。你可以在 `is` attribute 的值中加上 `vue:` 前缀，这样 Vue 就会把该元素渲染为 Vue 组件：

  template

  ```
  <table>
    <tr is="vue:my-row-component"></tr>
  </table>
  ```

- **参考**

  - [内置特殊元素 - ``](https://cn.vuejs.org/api/built-in-special-elements.html#component)
  - [动态组件](https://cn.vuejs.org/guide/essentials/component-basics.html#dynamic-components)

​	

##### 元素位置限制

某些 HTML 元素对于放在其中的元素类型有限制，例如 <ul>，<ol>，<table> 和 <select>，相应的，某些元素仅在放置于特定元素中时才会显示，例如 <li>，<tr> 和 <option>。

这将导致在使用带有此类限制元素的组件时出现问题。例如：

```template
<table>
  <blog-post-row></blog-post-row>
</table>
```

自定义的组件 <blog-post-row> 将作为无效的内容被忽略，因而在最终呈现的输出中造成错误。我们可以使用特殊的 `is` attribute 作为一种解决方案：

```template
<table>
  <tr is="vue:blog-post-row"></tr>
</table>
```

**TIP**

> 当使用在原生 HTML 元素上时，is 的值必须加上前缀 vue: 才可以被解析为一个 Vue 组件。这一点是必要的，为了避免和原生的自定义内置元素相混淆。

以上就是你需要了解的关于 DOM 模板解析的所有注意事项，同时也是 Vue 基础部分的所有内容。祝贺你！虽然还有很多需要学习的，但你可以先暂停一下，去用 Vue 做一些有趣的东西，或者研究一些示例。

完成了本页的阅读后，回顾一下你刚才所学到的知识，如果还想知道更多细节，我们推荐你继续阅读关于组件的完整指引。

### 组件注册

#### tree-shaking

**Tree shaking** 是一个用于优化 JavaScript 代码的术语，它的主要目标是去除未使用的代码，以减小最终构建（bundle）的文件大小。这个概念最初是由 Webpack 团队引入的，用于描述他们在打包工具中的优化技术。

#### 全局注册组件的缺点

- 全局注册组件，即使它并没有被实际使用，但无法在生产打包时被自动移除 (也叫“tree-shaking”)，也就是说它仍然会出现在打包后的 JS 文件中。

- 全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。

相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。

​	

在使用 `<script setup>` 的单文件组件中，导入的组件可以直接在模板中使用，无需注册：

```vue
<script setup>
import ComponentA from './ComponentA.vue'
</script>

<template>
  <ComponentA />
</template>
```

如果没有使用 `<script setup>`，则需要使用 `components` 选项来显式注册：

```js
import ComponentA from './ComponentA.js'

export default {
  components: {
    ComponentA
  },
  setup() {
    // ...
  }
}
```

对于每个 `components` 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于：

```js
export default {
  components: {
    ComponentA: ComponentA
  }
  // ...
}
```

请注意：**局部注册的组件在后代组件中并\*不\*可用**。在这个例子中，`ComponentA` 注册后仅在当前组件可用，而在任何的子组件或更深层的子组件中都不可用。（有点像废话，这句话的意思就是说，爸爸不能给儿子当儿子）

### Props

动态绑定的 props 要用 `v-bind` 或  `:` （即使动态绑定的是常量），**任何**类型的值都可以作为 props 的值被传递。

使用一个对象绑定多个 prop
如果你想要将一个对象的所有属性都当作 props 传入，你可以使用没有参数的 v-bind，即只使用 v-bind 而非 :prop-name。例如，这里有一个 post 对象：

```js
const post = {
  id: 1,
  title: 'My Journey with Vue'
}
```


以及下面的模板：

```template
<BlogPost v-bind="post" />
```


而这实际上等价于：

```template
<BlogPost :id="post.id" :title="post.title" />
```

​	

`defineProps()` 宏中的参数**不可以访问 `<script setup>` 中定义的其他变量**，因为在编译时整个表达式都会被移到外部的函数中。

工厂函数类似类的概念，定义好字面量，后面只需继承就好，没必要重复定义，优化代码

​	

一些补充细节：

- 所有 prop 默认都是可选的，除非声明了 `required: true`。
- 除 `Boolean` 外的未传递的可选 prop 将会有一个默认值 `undefined`。
- `Boolean` 类型的未传递 prop 将被转换为 `false`。这可以通过为它设置 `default` 来更改——例如：设置为 `default: undefined` 将与非布尔类型的 prop 的行为保持一致。
- 如果声明了 `default` 值，那么在 prop 的值被解析为 `undefined` 时，无论 prop 是未被传递还是显式指明的 `undefined`，都会改为 `default` 值。

当 prop 的校验失败后，Vue 会抛出一个控制台警告 (在开发模式下)。

如果使用了[基于类型的 prop 声明](https://cn.vuejs.org/api/sfc-script-setup.html#type-only-props-emit-declarations) ，Vue 会尽最大努力在运行时按照 prop 的类型标注进行编译。举例来说，`defineProps<{ msg: string }>` 会被编译为 `{ msg: { type: String, required: true }}`。

​	

#### 宏是什么

> "宏" 通常指的是编程语言中的宏（Macro），它是一种用于代码生成和代码重用的技术。宏允许程序员定义一些抽象的代码片段，然后在代码中引用这些宏，编译器或预处理器会将宏展开为实际的代码片段。
>
> 在不同的编程语言和环境中，宏有不同的实现方式和语法。下面是一些常见的宏的用途和示例：
>
> 1. **预处理器宏（C/C++）：** 在C和C++中，预处理器宏是使用 `#define` 指令定义的符号，用于在代码中进行文本替换。这些宏在编译前由预处理器处理，并且通常用于创建常量、简化代码、以及条件编译等任务。
>
>    ```c
>    #define MAX(a, b) ((a) > (b) ? (a) : (b))
>
>    int result = MAX(10, 20); // 展开为 int result = ((10) > (20) ? (10) : (20));
>    ```
>
> 2. **函数宏（Lisp）：** Lisp编程语言使用宏来定义新的语法，以简化代码。Lisp宏允许程序员创建自定义的控制结构和DSL（领域特定语言）。
>
>    ```lisp
>    (defmacro when (condition &rest body)
>      `(if ,condition (progn ,@body)))
>    
>    (when (> x 10)
>      (print "x is greater than 10"))
>    ```
>
> 3. **模板宏（Rust）：** Rust编程语言引入了宏系统，允许程序员编写自定义的代码生成器。Rust宏可以生成代码、处理模式匹配等。
>
>    ```rust
>    macro_rules! my_print {
>        () => (println!("Hello, world!"));
>    }
>    
>    my_print!(); // 展开为 println!("Hello, world!");
>    ```
>
> 4. **文本宏（JavaScript）：** 在JavaScript中，文本宏是一种在编译期间或运行时处理字符串文本的技术。它通常涉及使用模板字符串或正则表达式来进行文本操作。
>
>    ```javascript
>    const name = "Alice";
>    const greeting = `Hello, ${name}!`; // 使用文本宏，将变量插入到字符串中
>    ```
>
> 总的来说，宏是一种强大的代码生成和抽象化工具，它可以用于简化代码、提高可读性、创建新的语法结构以及实现高度通用的函数和模板。不同编程语言和环境提供了不同类型的宏，每种宏都有其自己的用途和语法规则。

​	

`instanceof` 用于判断实例属于哪个类或构造函数，具体用法：`实例` instanceof `类/构造函数`

​	

#### Boolean 类型转换

当一个 prop 被声明为允许多种类型时，`Boolean` 的转换规则也将被应用。然而，当同时允许 `String` 和 `Boolean` 时，有一种边缘情况——只有当 `Boolean` 出现在 `String` 之前时，`Boolean` 转换规则才适用：

```js
// disabled 将被转换为 true
defineProps({
  disabled: [Boolean, Number]
})
  
// disabled 将被转换为 true
defineProps({
  disabled: [Boolean, String]
})
  
// disabled 将被转换为 true
defineProps({
  disabled: [Number, Boolean]
})
  
// disabled 将被解析为空字符串 (disabled="")
defineProps({
  disabled: [String, Boolean]
})
```

​	

### 组件事件

像组件与 prop 一样，事件的名字也提供了自动的格式转换。注意这里我们触发了一个以 camelCase 形式命名的事件，但在父组件中可以使用 kebab-case 形式来监听。与 [prop 大小写格式](https://cn.vuejs.org/guide/components/props.html#prop-name-casing)一样，在模板中我们也推荐使用 kebab-case 形式来编写监听器。

> 和原生 DOM 事件不一样，组件触发的事件**没有冒泡机制**。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的事件总线，或是使用一个[全局状态管理方案](https://cn.vuejs.org/guide/scaling-up/state-management.html)。

​	

==”组件触发的事件没有冒泡机制。你只能监听直接子组件触发的事件。“，这句话怎么理解？==

> 这句话是在上下文中讨论 Vue.js 组件中的事件传递时提到的。让我解释一下它的含义：
>
> 在 Vue.js 中，组件之间可以通过触发和监听事件来进行通信。一个组件可以触发（发射）一个自定义事件，而另一个组件可以监听这个事件来获取信息或执行某些操作。然而，需要理解的是，Vue 组件的事件传递是基于组件树结构的，它并不像浏览器中的原生事件那样具有冒泡机制。
>
> 具体来说，这句话的含义是：
>
> 1. **组件触发的事件没有冒泡机制：** 当一个组件触发（发射）一个自定义事件时，这个事件不会像原生DOM事件那样自动向上传递到父组件、祖父组件或其他组件。它只会在组件内部进行传播。
>
> 2. **只能监听直接子组件触发的事件：** 如果你希望父组件监听子组件触发的事件，那么监听事件的父组件必须直接包含这个子组件。如果在父组件的祖父组件或更高层级的组件中监听，是无法直接捕获到子组件触发的事件的，因为事件传递不会跳过层级。
>
> 这意味着事件的传递是局部的，只在触发事件的组件及其子组件之间进行，不会自动传递到更高层级的组件。如果需要在更高层级的组件中监听事件，你需要手动将事件通过嵌套层级的每个组件传递，或者考虑使用全局事件总线或状态管理工具（如 Vuex）来实现组件之间的全局通信。
>
> 总之，Vue.js 的事件传递是基于组件树结构的，要理解哪些组件可以监听哪些事件，需要考虑组件的层级关系。这种设计有助于组件之间的隔离和封装，但也需要开发者在组件通信时进行适当的设计和管理。

==那哪些有冒泡机制==

> 冒泡机制通常与浏览器中的原生 DOM 事件相关联，但并不是所有原生 DOM 事件都支持冒泡机制。以下是一些具有冒泡机制的常见原生 DOM 事件：
>
> 1. **点击事件（click）：** 当用户点击页面上的元素时，点击事件会从被点击的元素开始冒泡，并依次传递给它的父元素，直到达到文档树的根节点。
>
> 2. **鼠标事件（mouseenter、mouseleave、mouseover、mouseout）：** 这些事件在鼠标进入或离开元素以及在元素上移动时都会触发，并支持冒泡。
>
> 3. **键盘事件（keydown、keyup）：** 当用户按下或释放键盘上的按键时，键盘事件会从触发事件的元素开始冒泡。
>
> 4. **表单事件（submit、input、change）：** 表单元素上的事件，如提交表单、输入文本、选择选项等，也支持冒泡。
>
> 5. **焦点事件（focus、blur）：** 当元素获取或失去焦点时，焦点事件也会冒泡。
>
> 6. **自定义事件（Custom Events）：** 你可以创建自定义事件，并在需要的时候触发它们。自定义事件可以选择是否冒泡，因此你可以根据需求自由控制。
>
> 请注意，并不是所有事件都支持冒泡。例如，`mousemove` 事件通常不冒泡，它只在触发事件的元素上触发，而不传递给父元素。冒泡是一种事件传递的机制，它可以让你在文档树中的多个元素之间传递事件，以便更灵活地处理用户交互。
>
> 需要特别注意的是，Vue.js 的自定义事件是不支持冒泡的，只会在触发事件的组件及其子组件之间传递，不会自动冒泡到更高层级的组件。这与原生 DOM 事件的冒泡机制不同。如果需要在 Vue.js 中实现类似冒泡的行为，你需要手动设计事件传递逻辑。

#### v-on

给元素绑定事件监听器。

- **缩写：**`@`

- **期望的绑定值类型：**`Function | Inline Statement | Object (不带参数)`

- **参数：**`event` (使用对象语法则为可选项)

- **修饰符**

  - `.stop` - 调用 `event.stopPropagation()`。
  - `.prevent` - 调用 `event.preventDefault()`。
  - `.capture` - 在捕获模式添加事件监听器。
  - `.self` - 只有事件从元素本身发出才触发处理函数。
  - `.{keyAlias}` - 只在某些按键下触发处理函数。
  - `.once` - 最多触发一次处理函数。
  - `.left` - 只在鼠标左键事件触发处理函数。
  - `.right` - 只在鼠标右键事件触发处理函数。
  - `.middle` - 只在鼠标中键事件触发处理函数。
  - `.passive` - 通过 `{ passive: true }` 附加一个 DOM 事件。

- **详细信息**

  事件类型由参数来指定。表达式可以是一个方法名，一个内联声明，如果有修饰符则可省略。

  当用于普通元素，只监听[**原生 DOM 事件**](https://developer.mozilla.org/en-US/docs/Web/Events)。当用于自定义元素组件，则监听子组件触发的**自定义事件**。

  当监听原生 DOM 事件时，方法接收原生事件作为唯一参数。如果使用内联声明，声明可以访问一个特殊的 `$event` 变量：`v-on:click="handle('ok', $event)"`。

  `v-on` 还支持绑定不带参数的事件/监听器对的对象。请注意，当使用对象语法时，不支持任何修饰符。

- **示例**

  ```vue
  <!-- 方法处理函数 -->
  <button v-on:click="doThis"></button>
  
  <!-- 动态事件 -->
  <button v-on:[event]="doThis"></button>
  
  <!-- 内联声明 -->
  <button v-on:click="doThat('hello', $event)"></button>
  
  <!-- 缩写 -->
  <button @click="doThis"></button>
  
  <!-- 使用缩写的动态事件 -->
  <button @[event]="doThis"></button>
  
  <!-- 停止传播 -->
  <button @click.stop="doThis"></button>
  
  <!-- 阻止默认事件 -->
  <button @click.prevent="doThis"></button>
  
  <!-- 不带表达式地阻止默认事件 -->
  <form @submit.prevent></form>
  
  <!-- 链式调用修饰符 -->
  <button @click.stop.prevent="doThis"></button>
  
  <!-- 按键用于 keyAlias 修饰符-->
  <input @keyup.enter="onEnter" />
  
  <!-- 点击事件将最多触发一次 -->
  <button v-on:click.once="doThis"></button>
  
  <!-- 对象语法 -->
  <button v-on="{ mousedown: doThis, mouseup: doThat }"></button>
  ```

  监听子组件的自定义事件 (当子组件的“my-event”事件被触发，处理函数将被调用)：

  ```vue
  <MyComponent @my-event="handleThis" />
  
  <!-- 内联声明 -->
  <MyComponent @my-event="handleThis(123, $event)" />
  ```

- **参考**

  - [事件处理](https://cn.vuejs.org/guide/essentials/event-handling.html)
  - [组件 - 自定义事件](https://cn.vuejs.org/guide/essentials/component-basics.html#listening-to-events)

​	

#### 内联声明

内联声明（Inline Declaration）是指在Vue.js模板中直接声明事件处理函数或绑定方法，并且可以在声明时传递参数。通常，内联声明是通过在模板中使用 `@` 符号来绑定事件，并在事件后面使用括号 `()` 来传递参数。

在Vue.js中，有两种方式声明事件处理函数：

1. **非内联声明（Non-Inline Declaration）**：事件处理函数通常在组件的 `methods` 部分中定义，然后在模板中通过方法名来引用。这种方式适用于在多个地方重复使用相同的事件处理函数。

   ```vue
   <!-- 在模板中绑定事件，引用组件中的方法 -->
   <button @click="handleClick">Click me</button>
   ```

   ```vue
   // 在组件中定义方法
   methods: {
     handleClick() {
       // 处理点击事件
     },
   },
   ```

2. **内联声明（Inline Declaration）**：事件处理函数可以直接在模板中声明，并且可以在声明时传递参数。这种方式适用于需要在事件绑定时传递特定数据给事件处理函数的情况。

   ```vue
   <!-- 在模板中绑定事件，并传递参数 -->
   <button @click="handleClick(123, 'Hello')">Click me</button>
   ```

   这里的 `handleClick(123, 'Hello')` 是一个内联声明，因为事件处理函数直接在模板中定义，并且传递了参数 `123` 和 `'Hello'` 给事件处理函数。

内联声明通常用于在模板中灵活地传递数据给事件处理函数，而不必在组件的 `methods` 中提前定义一个方法。这对于需要在不同地方使用不同的参数调用相同事件处理函数的情况很有用。但请注意，内联声明可能使模板变得复杂，因此需要谨慎使用，以确保代码的可读性和维护性。

​	

##### 也就是说函数是直接在模板中定义的？

是的，内联声明中的函数是直接在模板中定义的。在Vue.js模板中，你可以使用内联声明来定义事件处理函数，而无需在组件的`methods`部分事先声明它们。这样可以使模板更加灵活，允许你传递特定的参数给事件处理函数。

例如，以下示例中的内联声明定义了一个点击事件处理函数，它在点击按钮时会触发，同时传递了参数：

```vue
<button @click="handleClick(123, 'Hello')">Click me</button>
```

在上述示例中，`handleClick` 函数是直接在模板中定义的，而不需要在组件的 `methods` 部分预先声明它。这使得你可以轻松地在模板中处理事件并传递特定的参数，而无需为每个事件都创建额外的方法。这对于一次性或特定上下文的事件处理非常有用，但在处理复杂逻辑的情况下，建议仍然将事件处理函数放在组件的 `methods` 部分，以提高代码的可维护性。

​	

#### 事件参数

![image-20230912204600975](8月23日.assets/image-20230912204600975.png)

#### 声明触发的事件

> 如果一个原生事件的名字 (例如 `click`) 被定义在 `emits` 选项中，则监听器只会监听组件触发的 `click` 事件而不会再响应原生的 `click` 事件。

​	

### 透传 Attributes

![image-20230913164649052](8月23日.assets/image-20230913164649052.png)

#### [`v-on` 监听器继承](https://cn.vuejs.org/guide/components/attrs.html#v-on-listener-inheritance)

同样的规则也适用于 `v-on` 事件监听器：

```vue
<MyButton @click="onClick" />
```

`click` 监听器会被添加到 `<MyButton>` 的根元素，即那个原生的 `<button>` 元素之上。当原生的 `<button>` 被点击，会触发父组件的 `onClick` 方法。同样的，如果原生 `button` 元素自身也通过 `v-on` 绑定了一个事件监听器，则这个监听器和从父组件继承的监听器都会被触发。

​	

````html
下面内容帮助我理解：

### 深层组件继承​
有些情况下一个组件会在根节点上渲染另一个组件。例如，我们重构一下 <MyButton>，让它在根节点上渲染 <BaseButton>：

```template
<!-- <MyButton/> 的模板，只是渲染另一个组件 -->
<BaseButton />
```

此时 <MyButton> 接收的透传 attribute 会直接继续传给 <BaseButton>。
````

这段文档中描述的是深层组件继承的概念。让我解释一下：

1. 通常情况下，Vue 组件是树形结构的，其中一个组件可以包含其他组件作为其子组件。例如，一个按钮组件 `<MyButton>` 可以包含一个基础按钮组件 `<BaseButton>` 作为它的子组件。

2. 在某些情况下，当你对一个组件进行重构或扩展时，你可能希望在新的组件中直接渲染另一个组件，而不是从头开始编写新的模板。这就是所谓的深层组件继承。

3. 在上述示例中，`<MyButton>` 组件的模板中只包含了一个 `<BaseButton>` 组件，而没有其他内容。这意味着 `<MyButton>` 组件在根节点上渲染了 `<BaseButton>` 组件。

4. 重要的是，任何传递给 `<MyButton>` 组件的属性（attribute）都会直接传递给 `<BaseButton>` 组件。这是因为 `<MyButton>` 组件的模板中没有消耗这些属性，所以它们会继续传递到 `<BaseButton>` 组件，作为透传属性。

5. 这种深层组件继承的方式可以用于构建复杂的组件，其中一个组件可以继承另一个组件的功能，并根据需要进行自定义。这可以减少代码的重复，并使代码更易于维护。

**请注意：**

- 透传的 attribute 不会包含 `<MyButton>` 上声明过的 props 或是针对 `emits` 声明事件的 `v-on` 侦听函数，换句话说，声明过的 props 和侦听函数被 `<MyButton>`“消费”了。

- 透传的 attribute 若符合声明，也可以作为 props 传入 `<BaseButton>`。

总之，深层组件继承是一种在Vue中扩展或重构组件的方法，允许你在一个组件中直接渲染另一个组件，并且可以透传属性以实现更高度的可复用性和定制性。

​	

inherit：继承

​	

#### 禁用 Attributes 继承

最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 `inheritAttrs` 选项为 `false`，你可以完全控制透传进来的 attribute 被如何使用。

现在我们要再次使用一下[之前小节](https://cn.vuejs.org/guide/components/attrs.html#attribute-inheritance)中的 `<MyButton>` 组件例子。有时候我们可能为了样式，需要在 `<button>` 元素外包装一层 `<div>`：

```vue
<div class="btn-wrapper">
  <button class="btn">click me</button>
</div>
```

我们想要所有像 `class` 和 `v-on` 监听器这样的透传 attribute 都应用在内部的 `<button>` 上而不是外层的 `<div>` 上。我们可以通过设定 `inheritAttrs: false` 和使用 `v-bind="$attrs"` 来实现：

```vue
<div class="btn-wrapper">
  <button class="btn" v-bind="$attrs">click me</button>
</div>
```

小提示：[没有参数的 `v-bind`](https://cn.vuejs.org/guide/essentials/template-syntax.html#dynamically-binding-multiple-attributes) 会将一个对象的所有属性都作为 attribute 应用到目标元素上。

​	

### 状态管理

#### 全局单例是什么

"全局单例" 是一种设计模式，它指的是在一个应用程序中只创建一个实例（单例）并在整个应用程序的生命周期内共享这个实例。这意味着无论在应用程序的哪个部分都可以访问和操作相同的对象或资源。

全局单例通常用于以下情况：

1. **资源共享**：当应用程序需要访问一些全局资源，如配置、状态管理、日志记录器等时，全局单例可以确保只有一个实例，并且在整个应用程序中共享这些资源。

2. **性能优化**：某些对象的创建和销毁可能会带来较大的开销，全局单例可以减少对象的创建次数，提高性能。

3. **状态管理**：在前端应用程序中，全局单例可以用于状态管理，例如使用 Vuex 在Vue.js应用程序中管理应用程序的状态。

4. **连接到外部资源**：当应用程序需要连接到外部资源，如数据库、网络服务等时，全局单例可以确保只有一个连接实例，以避免资源浪费和冲突。

然而，全局单例也应该谨慎使用。滥用全局单例可能会导致全局状态混乱，难以维护和测试。因此，在使用全局单例时，需要仔细考虑何时和如何使用，并确保只在有必要的情况下使用它。

#### 全局单例和vuex有什么区别

全局单例和 Vuex 都是在 Vue.js 应用程序中管理全局状态的方法，但它们有一些区别：

1. **使用范围**:
   - **全局单例** 是一种通用的设计模式，它不限于任何特定的框架或库。你可以在任何 JavaScript 应用程序中使用全局单例，包括非 Vue.js 项目。
   - **Vuex** 是专门为 Vue.js 应用程序设计的状态管理库。它提供了专门的状态管理工具和 Vue.js 的集成，使你能够更轻松地管理 Vue 组件之间的状态。

2. **架构**:
   - **全局单例** 可以是一个普通的 JavaScript 对象或类，它可以包含任何你需要在应用程序中共享的状态或功能。全局单例没有固定的架构，你可以根据需要自定义。
   - **Vuex** 提供了一种特定的架构和规范，它包括状态（State）、突变（Mutations）、动作（Actions）、获取器（Getters）等核心概念。这种结构化的状态管理使得在大型 Vue.js 应用程序中更容易管理状态。

3. **工具和插件**:
   - **全局单例** 可以手动创建和管理，你可以使用普通的 JavaScript 代码来实现它。
   - **Vuex** 是一个专门的库，它提供了一些开箱即用的工具和插件，如 Vue Devtools 支持、严格模式等，以帮助你更容易地开发和调试 Vue.js 应用程序。

4. **Vue.js 集成**:
   - **全局单例** 可以与任何框架或库集成，但不会提供 Vue.js 特定的集成。
   - **Vuex** 是为 Vue.js 设计的，与 Vue.js 集成紧密。它提供了 Vue.js 组件中直接访问和修改状态的方式，使得在 Vue.js 项目中更加方便和一致。

总的来说，全局单例是一种更通用的状态管理方法，适用于各种应用程序。而 Vuex 是专门为 Vue.js 应用程序设计的状态管理解决方案，它提供了一种结构化的方法来管理 Vue 组件之间的状态，以及一些特定于 Vue.js 的工具和插件。选择使用哪种方法取决于你的项目需求和技术栈。

​	

#### reactive()

##### vue3中ref和reactive的解包是什么意思

在 Vue 3 中，`ref` 和 `reactive` 是用于创建响应式数据的两种不同方式，它们的解包（Unwrapping）指的是访问存储在响应式对象中的原始数据值。解包可以通过 `.value` 属性（对于 `ref`）或 `toRefs` 函数（对于 `reactive`）来完成。

1. **`ref` 的解包**：使用 `ref` 创建的响应式对象需要通过 `.value` 属性来解包，以访问原始的数据值。例如：

   ```javascript
   import { ref } from 'vue';

   const count = ref(0); // 创建一个 ref

   // 解包 ref
   const originalValue = count.value;
   ```

   在这里，我们通过 `count.value` 来解包 `ref`，以获取 `0` 这个原始的数据值。

2. **`reactive` 的解包**：使用 `reactive` 创建的响应式对象可以使用 `toRefs` 函数来进行解包。`toRefs` 将一个包含响应式数据的对象解包成一个包含原始数据值的对象。例如：

   ```javascript
   import { reactive, toRefs } from 'vue';
   
   const state = reactive({ count: 0 }); // 创建一个 reactive
   
   // 解包 reactive
   const { count } = toRefs(state);
   ```

   在这里，我们通过 `toRefs` 将 `state` 中的 `count` 解包成一个包含原始数据值的对象，可以像 `count` 一样使用它。

解包是因为 Vue 3 使用 Proxy 来实现响应式，通过 `.value` 或 `toRefs` 来访问原始数据，以确保 Vue 可以正确地追踪数据的变化。这个解包的过程对于数据的读取非常重要，但在修改数据时通常不需要解包，因为 Vue 3 可以自动追踪数据的变化。

​	

##### console.log(obj.count === count.value) // true

```js
下面代码中obj.count是原始数据吗，因为双重解包的缘故？

const count = ref(1)
const obj = reactive({ count })

// ref 会被解包
console.log(obj.count === count.value) // true

---
补充：Vue3的ref和reactive，跟js的基本数据类型和引用数据类型异曲同工之妙，ref解包基本数据类型，所以通过 count.value 直接访问到原始数据，而reactive解包引用数据类型（解包后仍是包含原始数据的响应式对象），所以直接 obj.count 便可以访问值（修改值的话代理对象会代理修改原始数据），Vue 3 会自动解包 `obj.count`，然后比较它们的原始数据值
当然了你也可以通过obj.count.value 访问值
```

> 在你提供的代码中，`obj.count` 并不是原始数据，而是一个包含原始数据的响应式对象。这是因为 `count` 是通过 `ref` 创建的，而 `ref` 创建的响应式对象需要通过 `.value` 属性来解包才能访问原始数据。因此，`count.value` 表示 `count` 的原始数据，而 `obj.count` 表示包含 `count` 原始数据的响应式对象。
>
> 在代码中，你创建了一个 `ref` 变量 `count`，然后将它包含在一个 `reactive` 对象 `obj` 中。尽管 `count` 是一个 `ref` 变量，但它在 `obj` 中仍然被包装为响应式对象。因此，当你访问 `obj.count` 时，它会返回一个响应式对象，而不是原始数据。
>
> 要访问原始数据，你应该使用 `count.value`。所以，`console.log(obj.count === count.value)` 的结果是 `true`，因为它们都引用了相同的原始数据。如果你想要访问原始数据的值，你可以使用 `count.value`，而不需要双重解包。

**也就说count.value是原始数据，而obj.count 表示包含 count 原始数据的响应式对象？**

是的，你理解得正确。

在你的示例中，`count.value` 表示原始数据，而 `obj.count` 表示包含 `count` 原始数据的响应式对象。虽然 `count` 本身是一个 `ref` 变量，但将它包含在 `reactive` 对象 `obj` 中后，`obj.count` 就变成了一个响应式对象，它内部包含了 `count` 的原始数据。

要访问原始数据的值，你可以使用 `count.value`，而要访问包含原始数据的响应式对象，你可以使用 `obj.count`。这种区别很重要，因为在 Vue 3 中，访问响应式数据时需要知道何时使用 `.value` 解包以及何时不需要。

**那为什么他们  ===  会是true呢，这一个原始数据一个包含原始数据的响应式对象，不是不应该全等于吗？**

你提到的 `===` 全等操作符在比较 `count.value` 和 `obj.count` 时返回 `true` 是因为 Vue 3 在内部处理了这个情况，以确保相等性比较正常工作。这是 Vue 3 中的设计决策之一，用于提供更好的开发人员体验。

实际上，Vue 3 中的响应式对象内部会重写 JavaScript 原生的比较操作符，以使比较更直观且符合预期。这是为了让开发人员更容易地与响应式数据交互，而不必担心深层的解包。

当你比较 `count.value` 和 `obj.count` 时，Vue 3 会自动解包 `obj.count`，然后比较它们的原始数据值。这样，无论是 `count.value` 还是 `obj.count`，你都可以正确地比较它们的值，而不必手动解包。

因此，`count.value` 和 `obj.count` 的比较操作是合理的，因为它们的原始数据是相等的。这种设计使得在 Vue 3 中处理响应式数据更加方便和直观。

​	

##### 如果我想要访问reactive对象的原始数据，需要怎么做

如果你想要访问 `reactive` 对象的原始数据，你可以使用 `toRefs` 函数来将整个对象解包为一个包含原始数据的对象。这将使你能够直接访问原始数据而不是响应式对象。

以下是一个示例：

```javascript
import { reactive, toRefs } from 'vue';

const state = reactive({
  count: 0,
  name: 'John',
});

// 使用 toRefs 解包整个 state 对象
const stateRefs = toRefs(state);

// 现在你可以直接访问原始数据
console.log(stateRefs.count); // 输出原始数据 0
console.log(stateRefs.name);  // 输出原始数据 'John'
```

在这个示例中，`toRefs` 函数将整个 `state` 对象解包为一个包含原始数据的对象 `stateRefs`。然后，你可以直接访问 `stateRefs` 中的属性，它们都表示原始数据。

需要注意的是，使用 `toRefs` 可以一次性解包整个对象，但也可以选择单独解包对象的属性。这取决于你的需求，如果你只想解包对象的特定属性，可以不使用 `toRefs`，而是直接访问属性的 `.value`，例如 `state.count.value`。但如果你需要访问多个属性，`toRefs` 可以更方便地进行批量解包。

**也就说我也可以直接像ref那样通过state.count.value访问到count属性的值0是吗？**

是的，你可以直接像 `ref` 那样通过 `state.count.value` 来访问 `count` 属性的原始数据值，因为 `count` 是通过 `reactive` 创建的响应式对象。

以下是示例：

```javascript
import { reactive } from 'vue';

const state = reactive({
  count: 0,
  name: 'John',
});

// 访问 count 属性的原始数据值
console.log(state.count.value); // 输出原始数据 0
```

在上述示例中，我们使用 `state.count.value` 来访问 `count` 属性的原始数据值 `0`。这种方式与 `ref` 中的 `.value` 属性的使用方式相似，允许你访问响应式对象的属性的原始数据值。

​	

我们使用`toRefs`将`user`对象的属性转换为引用，并且可以在函数内部通过引用修改属性的值。

​	

##### 所以reactive对象是引用类型的？

是的，Vue 3 中的 `reactive` 对象是引用类型。当你使用 `reactive` 函数创建一个对象时，它会返回一个代理对象（Proxy），而不是一个普通的 JavaScript 对象。这个代理对象会拦截对其属性的访问和修改，并将这些操作转发给原始对象，以实现响应式数据的追踪和更新。

由于 `reactive` 返回的是代理对象，所以这个对象本身是一个引用，它指向了原始对象。这意味着如果你将代理对象赋值给多个变量或传递给多个函数，它们都会引用相同的原始对象，而不是创建原始对象的副本。

以下是一个示例，演示了 `reactive` 对象的引用性质：

```javascript
import { reactive } from 'vue';

const originalObject = {
  name: 'John',
  age: 30,
};

const reactiveObject = reactive(originalObject);

// 修改代理对象的属性
reactiveObject.name = 'Alice';

console.log(originalObject.name);  // 输出: Alice，原始对象也被修改了

const referenceToObject = reactiveObject; // 引用相同的代理对象

referenceToObject.age = 31;

console.log(reactiveObject.age); // 输出: 31，代理对象被修改

// 注意：这里的 reactiveObject 和 referenceToObject 引用相同的代理对象
console.log(reactiveObject === referenceToObject); // 输出: true
```

在上面的示例中，我们创建了一个原始对象 `originalObject`，然后使用 `reactive` 创建了一个代理对象 `reactiveObject`。修改代理对象的属性会影响到原始对象，因为它们引用相同的对象。同时，`referenceToObject` 也引用了相同的代理对象。

所以，需要注意的是，在处理 `reactive` 对象时，你实际上在处理一个代理，而不是一个独立的对象。这一点在数据共享和响应式数据传递时非常重要。

​	

##### 下面代码为什么需要.value才能访问 const books = reactive([ref('Vue 3 Guide')]) // 这里需要 .value console.log(books[0].value)

在Vue 3中，`reactive`用于创建响应式对象，而`ref`用于创建响应式引用。当你将`ref`包装的值放入`reactive`对象中时，你需要使用`.value`来访问被包装的值，因为`ref`创建的是一个包装对象，而不是原始的值。

在你的代码中，`books`是一个响应式数组，而数组的元素可以是普通值或响应式引用。因为`ref`创建的是一个包装对象，所以在访问数组元素时，需要使用`.value`来访问包装对象中的值。

在`books`数组中，你包装了字符串 `'Vue 3 Guide'`，因此要访问它，需要使用`.value`，如下所示：

```javascript
const books = reactive([ref('Vue 3 Guide')]);

// 访问数组元素需要使用 .value
console.log(books[0].value); // 输出: Vue 3 Guide
```

这种方式允许Vue跟踪对数组元素的访问和修改，并在数据变化时进行响应式更新。如果你尝试直接访问`books[0]`而不使用`.value`，Vue 不会正确地追踪和更新该值的变化，因为它不知道这个值是一个响应式引用。

**如果是const books = reactive(['Vue 3 Guide']) 呢？结果会怎么样**

如果你的代码是这样的：

```javascript
const books = reactive(['Vue 3 Guide']);
```

那么 `books` 变量将包含一个响应式数组，其中的元素是字符串 `'Vue 3 Guide'`。在这种情况下，你不需要使用 `.value` 来访问数组元素，因为数组元素本身是普通的 JavaScript 值，而不是响应式引用。

你可以直接访问 `books` 数组的元素，如下所示：

```javascript
console.log(books[0]); // 输出: Vue 3 Guide
```

这是因为 `'Vue 3 Guide'` 是一个普通的字符串值，不需要 `.value`。只有当数组元素是响应式引用时，才需要使用 `.value` 来访问包装的值。在你的示例中，数组元素是一个字符串，所以不需要 `.value`。

```js
OK，那看下一个例子，下面代码为什么还要用.value来访问呢？
const map = reactive(new Map([['count', ref(0)]])) // 注意这里是map数据结构，也就是键值对的形式，所以ref(0)是'count'的值

// 这里需要 .value
console.log(map.get('count').value)
```

在这个例子中，`map` 是一个响应式 Map 对象，其中的值是响应式引用 `ref(0)`。当你从 Map 中获取值时，你实际上获得了一个响应式引用，因此你需要使用 `.value` 来访问被包装的值，就像之前提到的那样。

```javascript
const map = reactive(new Map([['count', ref(0)]]));

// 获取 Map 中的值需要使用 .value
console.log(map.get('count').value); // 输出: 0
```

在这种情况下，`map.get('count')` 返回的是一个包装的引用，它包含了 `ref(0)` 创建的响应式值。如果你直接访问 `map.get('count')`，你将得到这个引用对象，而不是其中的值。

使用 `.value` 来访问包装的引用是因为 Vue 需要追踪这个引用中的变化，以便在数据发生变化时触发视图更新。这种方式确保 Vue 可以正确地处理引用对象的响应式性质。

**我小结一下，凡是通过ref声明的变量，要访问其值都必须要通过.value访问，不管它放在哪里？**

是的，你的小结是正确的。当你使用 `ref` 声明变量时，不管这个变量放在哪里，都需要使用 `.value` 来访问它的值。这是因为 `ref` 创建的变量是一个响应式引用，而不是普通的 JavaScript 值，因此需要使用 `.value` 来访问其包装的值。

这一规则适用于 `ref` 创建的变量，但不适用于普通的 JavaScript 值。普通的 JavaScript 值可以直接访问，而不需要使用 `.value`。

所以，只有当你使用 `ref` 创建了一个响应式引用时，才需要记住使用 `.value` 来访问其值。

**但是要修改值不一定要通过 .value ，像把它赋值给reactive对象内部做对象属性**

不是的，在 Vue 3 中，`reactive`对象的属性通常不需要使用 `.value` 来修改值，因为 Vue 3 提供了更直观的方式来修改属性值。通常情况下，你可以直接对 `reactive` 对象的属性进行赋值，而不必使用 `.value`。

以下是一个示例，演示了如何直接修改 `reactive` 对象的属性值：

```js
import { reactive } from 'vue';

const user = reactive({
  name: 'John',
  age: 30,
});

// 直接修改属性值
user.name = 'Alice';
user.age = 31;

console.log(user.name); // 输出: Alice
console.log(user.age);  // 输出: 31
```

在上面的示例中，我们直接修改了 `user` 对象的属性值，而不需要使用 `.value`。

使用 `.value` 主要适用于 `ref` 创建的变量，以及当你在处理深层嵌套的响应式数据结构时，可能需要访问内部 `ref` 变量的值。对于普通的 `reactive` 对象属性，直接赋值即可。

**上面例子我这么写 user.age.value = 31，也是对的是吗？**

不，`user.age.value = 31` 不是正确的方式来修改属性值。当你使用 `reactive` 创建的对象时，应该像我之前示例中所演示的那样，直接对属性进行赋值，而不需要使用 `.value`。

正确的方式是这样：

```javascript
import { reactive } from 'vue';

const user = reactive({
  name: 'John',
  age: 30,
});

// 直接修改属性值
user.age = 31;

console.log(user.age);  // 输出: 31
```

使用 `.value` 是为了访问和修改 `ref` 创建的变量的值，而不是用于访问和修改 `reactive` 对象的属性。如果你尝试使用 `.value` 修改 `reactive` 对象的属性，它会将新的值包装在一个 `ref` 中，而不是修改属性的实际值。因此，对于 `reactive` 对象的属性，请直接赋值即可。

```js
下面例子我这么写改变值是 user.age.value = 31，是对的是吗？
const user = reactive({
  name: 'John',
  age: ref(30),
});
```

对的，你说得对。在这个例子中，`age` 是通过 `ref` 创建的变量，因此要访问和修改它的值，需要使用 `.value`。所以，你可以像这样修改 `age` 的值：

```javascript
user.age.value = 31;
```

这会将 `age` 的值从 30 修改为 31。因为 `age` 是一个 `ref` 变量，所以你需要使用 `.value` 来访问和修改它的值，这是正确的方式。

**但是 user.age = 31; 对吗**

对于使用 `ref` 包装的变量，赋值给 `user.age` 是不会生效的，因为 `user.age` 本身引用的是一个 `ref` 包装的值，而不是值的直接引用。所以，如果 `user.age` 是通过 `ref` 创建的，你需要使用 `.value` 来访问和修改它的值。

正确的方式是：

```javascript
user.age.value = 31;
```

这会修改 `age` 的值为 31，因为你访问的是 `ref` 包装的值。

---

将一个 [ref](https://cn.vuejs.org/api/reactivity-core.html#ref) 赋值给一个 `reactive` 属性时，该 ref 会被自动解包：

```ts
const count = ref(1)
const obj = reactive({})

obj.count = count

console.log(obj.count) // 1
console.log(obj.count === count.value) // true
```

---

---

最后提问一波ref和reactive

```js
下面代码的age，是不是不会自动解包？导致需要通过 .value 手动解包访问
const user = reactive({
  name: 'John',
  age: ref(30),
});
```

是的，你说得对。在这个代码示例中，`age` 是一个通过 `ref` 创建的变量，因此它是一个包装了数字值的 `ref` 对象。当你访问 `user.age` 时，它将返回这个 `ref` 对象，而不是直接的数字值。因此，如果你要访问 `age` 的实际值，你需要使用 `.value` 来手动解包它，就像这样：

```javascript
const actualAge = user.age.value; // 通过 .value 解包访问 age 的值
```

这是因为 `ref` 变量需要使用 `.value` 来访问和修改其包装的值。所以，在访问 `age` 的实际值时，你需要手动解包。

​	

```js
那下面这种情况的话就会自动解包吗？也就是说count不用通过 .value 访问？
const count = ref(1)
const obj = reactive({})
obj.count = count
```

在这种情况下，`count` 是一个通过 `ref` 创建的变量，但是当你将它赋值给 `obj.count` 时，Vue 会自动解包 `count`，因此你不需要在访问 `obj.count` 时使用 `.value`。

你可以直接访问 `obj.count` 来获取其值，就像访问普通的 JavaScript 属性一样，而不需要 `.value`。

```javascript
const count = ref(1);
const obj = reactive({});
obj.count = count; // Vue 会自动解包 count

console.log(obj.count); // 输出: 1
```

Vue 会自动处理响应式引用的解包，以确保你能够像访问普通属性一样访问 `obj.count` 的值。所以，在这个示例中，你不需要使用 `.value`。

##### ==所以内部声明的ref不会自动解包，而外部声明的ref通过赋值给reactive对象内部属性的方式会自动解包？==

是的，你的理解是正确的。

内部声明的 `ref` 变量不会自动解包，你需要手动使用 `.value` 来访问其值。例如：

```javascript
const count = ref(1);

// 访问 count 的值需要使用 .value
console.log(count.value); // 输出: 1
```

但是，当你将外部声明的 `ref` 变量赋值给 `reactive` 对象内部的属性时，Vue 会自动解包该 `ref` 变量，以确保你能够像访问普通属性一样访问其值，而不需要使用 `.value`。例如：

```javascript
const count = ref(1);
const obj = reactive({});
obj.count = count; // Vue 会自动解包 count

console.log(obj.count); // 输出: 1
```

这是 Vue 在处理响应式数据时的一个方便之处，它让你可以像处理普通属性一样处理包含 `ref` 的属性。

> 我的猜测：外部赋值ref给reactive对象内部属性，猜测是最开始定义的时候不是响应式引用，所以Vue3内部执行了自动解包的操作，所以不用用 .value 访问值
